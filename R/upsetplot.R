#' Detect the type of the input data for Upset plot
#'
#' @description
#' Automatically detects whether the input data is in long format, wide format,
#' list format, or an already processed UpsetPlotData object.
#'
#' @keywords internal
#' @param data A data frame or a list
#' @param group_by A character string specifying the column name of the data frame to group the data.
#' @param id_by A character string specifying the column name of the data frame to identify the instances.
#'   Required when `group_by` is a single column and data is a data frame.
#' @return A character string indicating the datatype of the input data or error message if invalid.
#'   Possible values are "long", "wide", "list" and "upset".
#'   - "long": Data is in long format (group_by column with id_by column)
#'   - "wide": Data is in wide format (multiple logical/binary columns)
#'   - "list": Data is a named list of vectors
#'   - "upset": Data is a pre-processed UpsetPlotData object
detect_upset_datatype <- function(data, group_by = NULL, id_by = NULL) {
  # Already processed UpsetPlotData object
  if (inherits(data, "UpsetPlotData")) {
    return("upset")
  }

  # Data frame: determine if long or wide format
  if (inherits(data, "data.frame")) {
    # Long format: single group_by column with an id_by column
    if (length(group_by) < 2 && !is.null(group_by)) {
      return("long")
    } else {
      # Wide format: multiple columns or no group_by specified
      return("wide")
    }
  }

  # Named list of vectors
  if (inherits(data, "list")) {
    return("list")
  }

  # Invalid data type
  stop("Invalid data type. Please provide a data frame, a list, or an UpsetPlotData object generated by prepare_upset_data().", call. = FALSE)
}


#' Prepare data for Upset plot
#'
#' @param data A data frame or a list or an UpsetPlotData object.
#' @param in_form A character string indicating the datatype of the input data.
#'   Possible values are "long", "wide", "list", "upset" or "auto".
#'   "long" indicates the data is in long format.
#'   "wide" indicates the data is in wide format.
#'   "list" indicates the data is a list.
#'   "upset" indicates the data is a UpsetPlotData object.
#'   "auto" indicates the function will detect the datatype of the input data.
#'
#' A long format data would look like:
#' \preformatted{
#' group_by id_by
#' A        a1
#' A        a2
#' B        a1
#' B        a3
#' ...
#' }
#'
#' A wide format data would look like:
#' \preformatted{
#' A    B
#' TRUE TRUE
#' TRUE FALSE
#' FALSE TRUE
#' ...
#' }
#'
#' A list format data would look like:
#' \preformatted{
#' list(A = c("a1", "a2"), B = c("a1", "a3"))
#' }
#'
#' An UpsetPlotData object is generated by prepare_upset_data() would look like:
#' \preformatted{
#' group_by
#' --------
#' list("A")  # a2
#' list("B")  # a3
#' list(c("A", "B"))  # a1
#' ...
#' }
#'
#' @param group_by A character string specifying the column name of the data frame to group the data.
#' @param group_by_sep A character string to concatenate the columns in `group_by`,
#'   if multiple columns are provided and the in_form is "long".
#' @param id_by A character string specifying the column name of the data frame to identify the instances.
#'  Required when `group_by` is a single column and data is a data frame.
#' @param specific A logical value to show the specific intersections only.
#'  ggVennDiagram, by default, only return the specific subsets of a region. However,
#'  sometimes, we want to show all the overlapping items for two or more sets.
#'  See \url{https://github.com/gaospecial/ggVennDiagram/issues/64} for more details.
#' @return A UpsetPlotData object
#' @keywords internal
#' @importFrom rlang sym
#' @importFrom dplyr distinct %>%
#' @importFrom utils getFromNamespace
#' @importFrom tidyr uncount
prepare_upset_data <- function(data, in_form = "auto", group_by = NULL, group_by_sep = "_", id_by = NULL, specific = TRUE) {
  # Auto-detect data format if not specified
  if (in_form == "auto") {
    in_form <- detect_upset_datatype(data, group_by, id_by)
  }

  # If data is already processed, return as is
  if (in_form == "upset") {
    if (!is.null(group_by)) {
      warning("The 'group_by' argument is ignored when the input data is an UpsetPlotData object.", immediate. = TRUE)
    }
    return(data)
  }

  # Get process_upset_data from ggVennDiagram package
  process_upset_data <- utils::getFromNamespace("process_upset_data", "ggVennDiagram")

  # Convert different input formats to list format
  if (in_form == "list") {
    listdata <- data
  } else if (in_form == "long") {
    # Long format: validate columns and convert to list
    group_by <- validate_columns(
      data,
      group_by,
      force_factor = TRUE,
      allow_multi = TRUE,
      concat_multi = TRUE,
      concat_sep = group_by_sep
    )
    listdata <- split(data[[id_by]], data[[group_by]])
  } else { # in_form == "wide"
    # Wide format: validate boolean/binary columns
    group_by <- validate_columns(data, group_by, allow_multi = TRUE)
    if (is.null(group_by)) {
      group_by <- colnames(data)
    }

    # Ensure all columns are logical or 0/1
    for (g in group_by) {
      if (!is.logical(data[[g]]) && !all(data[[g]] %in% c(0, 1))) {
        stop("The columns in 'group_by' must be logical or 0/1 when the in_form is 'wide'.", call. = FALSE)
      }
    }

    # Create temporary ID column for wide format conversion
    data$.id <- paste0("id", seq_len(nrow(data)))
    listdata <- lapply(group_by, function(g) {
      data[as.logical(data[[g]]), ".id", drop = TRUE]
    })
    names(listdata) <- group_by

    # Remove empty groups and warn user
    for (nm in names(listdata)) {
      if (length(listdata[[nm]]) == 0) {
        warning("The group '", nm, "' has no elements, ignored.", immediate. = TRUE)
        listdata[[nm]] <- NULL
      }
    }
  }

  # Process list data into upset format using ggVennDiagram
  data <- process_upset_data(ggVennDiagram::Venn(listdata), specific = specific)

  # Create labels with set names and sizes
  idnames <- paste0(
    as.character(data$left_data$set),
    " (",
    as.character(data$left_data$size),
    ")"
  )
  names(idnames) <- as.character(seq_along(idnames))

  # Extract main data with distinct intersections
  sep <- ifelse(specific, "/", "~")
  data <- dplyr::distinct(data$main_data, !!rlang::sym("id"), !!rlang::sym("size"))

  # Parse intersection IDs into readable labels
  data$Intersection <- lapply(as.character(data$id), function(x) {
    idnames[strsplit(x, sep, fixed = TRUE)[[1]]]
  })

  # Expand data to have one row per item in each intersection
  tidyr::uncount(data, !!rlang::sym("size"))
}

#' Atomic Upset plot
#'
#' @inheritParams parameters
#' @inheritParams prepare_upset_data
#' @param label A logical value to show the labels on the bars.
#' @param label_fg A character string specifying the color of the label text.
#' @param label_size A numeric value specifying the size of the label text.
#' @param label_bg A character string specifying the background color of the label.
#' @param label_bg_r A numeric value specifying the radius of the background of the label.
#' @param ... Additional arguments passed to [ggupset::scale_x_upset].
#' @return A ggplot object with Upset plot
#' @keywords internal
#' @importFrom rlang %||%
#' @importFrom ggplot2 geom_bar labs guide_colorbar scale_fill_gradientn aes after_stat theme element_line element_text
#' @importFrom ggrepel geom_text_repel
UpsetPlotAtomic <- function(
    data, in_form = "auto", group_by = NULL, group_by_sep = "_", id_by = NULL,
    label = TRUE, label_fg = "black", label_size = NULL, label_bg = "white", label_bg_r = 0.1,
    palette = "material-indigo", palcolor = NULL, alpha = 1, specific = TRUE,
    theme = "theme_ggforge", theme_args = list(), title = NULL, subtitle = NULL, xlab = NULL, ylab = NULL,
    aspect.ratio = 0.6, legend.position = "right", legend.direction = "vertical", levels = NULL, ...) {
  # Get ggplot function (with gglogger support)
  ggplot <- get_ggplot()

  # Prepare data for upset plot
  data <- prepare_upset_data(data, in_form, group_by, group_by_sep, id_by, specific)

  # Calculate text size scale
  base_size <- theme_args$base_size %||% 12
  text_size_scale <- base_size / 12

  # Build base plot with bar chart colored by count
  p <- ggplot(data, ggplot2::aes(x = !!rlang::sym("Intersection"))) +
    ggplot2::geom_bar(
      ggplot2::aes(fill = ggplot2::after_stat(!!rlang::sym("count"))),
      alpha = alpha,
      color = "black",
      width = 0.5
    ) +
    ggplot2::scale_fill_gradientn(
      n.breaks = 3,
      colors = get_palette(palette = palette, palcolor = palcolor),
      na.value = "grey80",
      guide = ggplot2::guide_colorbar(
        title = "",
        alpha = alpha,
        frame.colour = "black",
        ticks.colour = "black",
        frame.linewidth = 0.3,
        ticks.linewidth = 0.3,
        title.hjust = 0
      )
    )

  # Add count labels if requested
  if (isTRUE(label)) {
    p <- p + ggrepel::geom_text_repel(
      ggplot2::aes(label = ggplot2::after_stat(!!rlang::sym("count"))),
      stat = "count",
      colour = label_fg,
      size = label_size %||% (text_size_scale * 3.5),
      bg.color = label_bg,
      bg.r = label_bg_r,
      point.size = NA,
      max.overlaps = 100,
      force = 0,
      min.segment.length = 0,
      segment.colour = "black"
    )
  }

  # Add labels and upset scale
  p <- p +
    ggplot2::labs(
      title = title,
      subtitle = subtitle,
      x = xlab %||% "",
      y = ylab %||% "Intersection size"
    ) +
    ggupset::scale_x_upset(...)

  # Apply base theme
  p <- p + do.call(theme, theme_args)

  # Apply custom theme adjustments for upset plot
  p <- p +
    ggplot2::theme(
      aspect.ratio = aspect.ratio,
      legend.position = legend.position,
      legend.direction = legend.direction,
      panel.grid.major = ggplot2::element_line(colour = "grey80", linetype = 2)
    ) +
    ggupset::theme_combmatrix(
      combmatrix.label.text = ggplot2::element_text(size = 12 * text_size_scale, color = "black"),
      combmatrix.label.extra_spacing = 6
    )

  # Calculate dynamic plot dimensions based on data
  upset_args <- list(...)
  n_sets <- upset_args$n_sets %||% 99
  n_sets <- min(n_sets, length(unique(unlist(data$Intersection))))
  n_intersections <- upset_args$n_intersections %||% 99
  n_intersections <- min(n_intersections, length(unique(data$Intersection)))
  maxchars <- max(sapply(unique(unlist(data$Intersection)), nchar))

  height <- 4.5 + n_sets * 0.5
  width <- n_intersections * aspect.ratio + maxchars * 0.05

  # Adjust for legend position
  if (!identical(legend.position, "none")) {
    if (legend.position %in% c("right", "left")) {
      width <- width + 1
    } else if (legend.direction == "horizontal") {
      height <- height + 1
    } else {
      width <- width + 2
    }
  }

  # Store plot dimensions as attributes
  attr(p, "height") <- height
  attr(p, "width") <- width

  p
}

#' Upset Plot
#'
#' @description
#' Creates an UpSet plot to visualize intersections between sets. UpSet plots are
#' a more scalable alternative to Venn diagrams for showing set intersections.
#' The function supports multiple input formats: list, long, wide, and pre-processed
#' UpsetPlotData objects.
#'
#' @inheritParams parameters
#' @inheritParams UpsetPlotAtomic
#' @param in_form A character string indicating the datatype of the input data.
#'   Possible values are "auto", "long", "wide", "list", or "upset".
#'   Default is "auto" which will detect the format automatically.
#' @param split_by Column to split the data by for creating multiple plots
#' @param split_by_sep Separator for concatenating split_by columns
#' @param group_by Column(s) to group by (depends on in_form)
#' @param group_by_sep Separator for concatenating group_by columns
#' @param id_by Column identifying unique instances (required for long format)
#' @param label Whether to show count labels on bars
#' @param label_fg Color of label text
#' @param label_size Size of label text
#' @param label_bg Background color of labels
#' @param label_bg_r Radius of label background
#' @param specific Show only specific intersections (not all overlaps)
#' @param combine Whether to combine multiple plots
#' @param nrow Number of rows for combined plots
#' @param ncol Number of columns for combined plots
#' @param byrow Fill plots by row
#' @param axes Axis handling for combined plots
#' @param axis_titles Axis title handling for combined plots
#' @param guides Guide handling for combined plots
#' @param design Custom design for combined plots
#' @param seed Random seed for reproducibility
#' @param ... Additional arguments passed to [ggupset::scale_x_upset]
#'
#' @return A ggplot object, wrap_plots object, or a list of ggplot objects
#' @export
#' @examples
#' # Example 1: Basic upset plot with list input
#' data <- list(
#'   A = 1:5,
#'   B = 2:6,
#'   C = 3:7,
#'   D = 4:8
#' )
#' UpsetPlot(data)
#'
#' # Example 2: Without labels
#' UpsetPlot(data, label = FALSE)
#'
#' # Example 3: Custom palette and show all overlaps
#' UpsetPlot(data, palette = "Reds", specific = FALSE)
#'
#' # Example 4: Limit number of sets and intersections
#' UpsetPlot(data, n_sets = 3, n_intersections = 10)
#'
#' # Example 5: Wide format data
#' wide_data <- data.frame(
#'   A = c(TRUE, TRUE, FALSE, TRUE),
#'   B = c(TRUE, FALSE, TRUE, TRUE),
#'   C = c(FALSE, TRUE, TRUE, TRUE)
#' )
#' UpsetPlot(wide_data, in_form = "wide")
UpsetPlot <- function(
    data, in_form = c("auto", "long", "wide", "list", "upset"), split_by = NULL, split_by_sep = "_",
    group_by = NULL, group_by_sep = "_", id_by = NULL, label = TRUE, label_fg = "black",
    label_size = NULL, label_bg = "white", label_bg_r = 0.1, palette = "material-indigo", palcolor = NULL,
    alpha = 1, specific = TRUE, theme = "theme_ggforge", theme_args = list(), title = NULL, subtitle = NULL,
    xlab = NULL, ylab = NULL, aspect.ratio = 0.6, legend.position = "right", legend.direction = "vertical",
    combine = TRUE, nrow = NULL, ncol = NULL, byrow = TRUE, seed = 8525,
    axes = NULL, axis_titles = axes, guides = NULL, design = NULL, ...) {
  # Validate common arguments and set seed
  validate_common_args(
    seed = seed,
    split_by = split_by,
    theme = theme,
    palette = palette,
    alpha = alpha,
    aspect.ratio = aspect.ratio,
    legend.position = legend.position,
    legend.direction = legend.direction
  )

  # Match and process input format
  in_form <- match.arg(in_form)
  theme <- process_theme(theme)

  # Validate split_by only works with data frames
  if (!is.null(split_by) && !inherits(data, "data.frame")) {
    stop("'split_by' is only available for data frame.", call. = FALSE)
  }

  # Validate and process split_by column
  split_by <- validate_columns(
    data,
    split_by,
    force_factor = TRUE,
    allow_multi = TRUE,
    concat_multi = TRUE,
    concat_sep = split_by_sep
  )

  # Split data if split_by is provided
  if (!is.null(split_by)) {
    datas <- split(data, data[[split_by]])
    # Keep the order of factor levels
    datas <- datas[levels(data[[split_by]])]
  } else {
    datas <- list(data)
    names(datas) <- "..."
  }

  # Prepare palette and legend parameters for each split
  palette <- check_palette(palette, names(datas))
  palcolor <- check_palcolor(palcolor, names(datas))
  legend.direction <- check_legend_param(legend.direction, names(datas), "legend.direction")
  legend.position <- check_legend_param(legend.position, names(datas), "legend.position")

  # Create plots for each split
  plots <- lapply(
    names(datas), function(nm) {
      # Determine title for each plot
      default_title <- if (length(datas) == 1 && identical(nm, "...")) NULL else nm
      if (is.function(title)) {
        title <- title(default_title)
      } else {
        title <- title %||% default_title
      }

      # Auto-detect group_by columns for wide format if not specified
      if (is.null(group_by) && (in_form %in% c("auto", "wide"))) {
        group_by <- setdiff(colnames(datas[[nm]]), c(id_by, split_by))
      }

      # Create atomic plot
      UpsetPlotAtomic(
        datas[[nm]],
        in_form = in_form,
        group_by = group_by,
        group_by_sep = group_by_sep,
        id_by = id_by,
        label = label,
        label_fg = label_fg,
        label_size = label_size,
        label_bg = label_bg,
        label_bg_r = label_bg_r,
        palette = palette[[nm]],
        palcolor = palcolor[[nm]],
        alpha = alpha,
        specific = specific,
        theme = theme,
        theme_args = theme_args,
        title = title,
        subtitle = subtitle,
        xlab = xlab,
        ylab = ylab,
        aspect.ratio = aspect.ratio,
        legend.position = legend.position[[nm]],
        legend.direction = legend.direction[[nm]],
        ...
      )
    }
  )

  # Combine plots or return list
  combine_plots(
    plots,
    combine = combine,
    nrow = nrow,
    ncol = ncol,
    byrow = byrow,
    axes = axes,
    axis_titles = axis_titles,
    guides = guides,
    design = design
  )
}
